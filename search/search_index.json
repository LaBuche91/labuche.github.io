{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"VPSim Introduction Wath is VPSim ? Use Key VPSim concepts Speed and interoperability Transportation, industry, security & defense Content Main Repositorie Demo package content Documentation UML User Documentation Developer/Expert Documentation","title":"VPSim"},{"location":"#vpsim","text":"","title":"VPSim"},{"location":"#introduction","text":"Wath is VPSim ? Use Key VPSim concepts Speed and interoperability Transportation, industry, security & defense","title":"Introduction"},{"location":"#content","text":"Main Repositorie Demo package content","title":"Content"},{"location":"#documentation","text":"UML User Documentation Developer/Expert Documentation","title":"Documentation"},{"location":"ExpertDocumentation/","text":"Developer/Expert Documentation Please refer to the systemC repository for this part of the documentation. We will focus on an added value of VPSim, which is the dynamic instantiation of systemC modules to enable the exploration of different architectures. Why would you need a dynamic instanciation ? Actually, if you want to build a full system using systemC you will have to instantiate your modules statically. This can be a problem if you want to do automatic exploration of architectures because you will have to recompose your system and recompile your code on each minor/major modification. There is several benefits to use a dynamic instantiation: 1) Parametrization and Configurability: Dynamic instantiation allows you to parametrize your modules dynamically, making them more configurable. This is useful for example, when you want to create multiple instances of the same module with a different configuration. 2) Reusability: You can create generic modules that can be instantiated multiple times with different parameters making it easier to reuse components in different parts of your design simulated. 3) Flexible System Composition: Dynamic instantiation provides the flexibility to compose your system by adding or removing modules based on the specific requirements of the simulation. VPSim approach In VPSim, we use a dynamic instantiation of the different systemC modules that will compose your system. We also automatically bind those modules between them by using a specific process that we will explain in the dynamic instantiation process part. This approach allows you to have only one executable file for all the architectures you want to explore without having to recompile the entire model each time. Dynamic instanciation of modules in VPSim For this part, we advise you to look at the UML diagram of the dynamic instanciation process. 1) SesamIp class : SesamIp is an abstract class that is here to define all the properties and functions/methods that an IP would need to be integrated in VPSim (number of in/out ports, stats of the module, required/optional attributes, port binding\u2026). It contains a static attribute called RegisteredClasses, which represents all the known classes of components (systemC modules) that VPSim can dynamically instantiate for a system build. 2) DynamicComponents : DynamicComponents is a file where you define a structure for each systemC modules you would like to instantiate dynamically in VPSim. Each structure in this file inherits from SesamIp class and contains a member, which is a pointer to a systemC module. This allow you to define specific rules and behaviours for each SystemC modules you want to include in VPSim by overloading the virtual methods declared in SesamIp class. Each structure need to be registered in the RegisteredClasses static attribute to dynamically be instantiated in VPSim. 3) PlatformBuilder : PlatformBuilder is structure used to construct a platform (collection of SesamIp instances). The goal of PlatformBuilder is to instantiate all the IPs described in the XML, bind their ports (the in/out ports of each modules are identified with a Port Alias or automatically binded), and then finalize the module (if you need to consider other systemC modules in your implementation). In short, it builds the platform, binds the ports of each modules and finalizes the modules. The order of instantiation does not count in VPSim . All the modules are instantiated and then binded automatically or with port aliases specified in the XML. When all the modules are instantiated and binded, there is the finalization phase (if a module needs to consider another module to work has expected). Global approach SesamIp class SesamIp is an abstract class that is here to define all the properties and functions/methods that an IP would need to be integrated in VPSim (number of in/out ports, stats of the module, required/optional attributes, port binding\u2026). It contains a static attribute called RegisteredClasses, which represents all the known classes of components (systemC modules) that VPSim can dynamically instantiate for a system build. DynamicComponents class DynamicComponents is a file where you define a structure for each systemC modules you would like to instantiate dynamically in VPSim. Each structure in this file inherits from SesamIp class and contains a member, which is a pointer to a systemC module. This allow you to define specific rules and behaviours for each SystemC modules you want to include in VPSim by overloading the virtual methods declared in SesamIp class. Each structure need to be registered in the RegisteredClasses static attribute to dynamically be instantiated in VPSim. PlatformBuilder class PlatformBuilder is structure used to construct a platform (collection of SesamIp instances). The goal of PlatformBuilder is to instantiate all the IPs described in the XML, bind their ports (the in/out ports of each modules are identified with a Port Alias or automatically binded), and then finalize the module (if you need to consider other systemC modules in your implementation). In short, it builds the platform, binds the ports of each modules and finalizes the modules. Dynamic instanciation process Here is a simple representation of the dynamic instanciation process in VPSim: Steps to add a new systemC module into VPSim 1) Include your systemC module into the dynamicComponent file so that you can reference it in a structure. 2) Define the DynamicModuleName structure related to your systemC module : - Define the required/optional attributes of the module in the constructor - Create a pointer to the actual SystemC module has a member of your structure - Overload the virtual functions of the sesamIp class. You have to overload at least the make function (Make() to instantiate the module and create a pointer to the actual systeC module) and the finalize function if you need to do something with the module in relation with other instances ONCE ALL THE OTHER MODULES ARE INSTANCIATED. 3) Register the structure you have just defined by calling registerClass (\u201cNameForXMLInterpretation\u201d) in the main. This will allow you to use it in the XML with the name \u201cNameForXMLInterpretation\u201d. Then the dynamic instantiation will be handled by platformBuilder (following the XML description of the platform). Concrete exemple of the make and finalize functions : a NoC memory controller Let\u2019s say you want to add a NoC memory controller into VPSim. You will have to create a new structure into DynamicComponents.hpp called \u201cDynamicNocMemoryController\u201d that inherits from SesamIp class. Constructor: For the constructor of this structure you will have to give a name as a parameter to the constructor to create a unique SesamIp object (since it inherits from sesamIp). In this constructor, you will define at least the required attributes of a NoC memory controller by calling registerRequiredAttribute from the sesamIp class. These are the required attributes for NoC memory controller: - Size represents the size that the NoC memory controller will handle - Base_address represents the base address on which the NoC memory controller starts - Noc represents the name of the NoC on which the memory controller will be assigned - x_id represents the abscissa position on the NoC where the memory controller will be assigned - y_id represents the ordinate position on the NoC where the memory controller will be assigned make function: In VPSim a memory controller isn\u2019t really a systemC module. It is a structure that defines for a NoC on which position is assigned a memory component. In this case, you only override the make function to check if the required attributes are all specified in the XML by calling the checkAttribute function from SesamIp class. finalize function: Has said, finalize is called only when all the modules that compose your platform are instantiated (so the make function has already been called on each modules). The difference between the two functions is that in finalize, you can consider other IP instances (has all the modules are instantiated). In this case, we first create a pointer to the NoC instance you want to assign the NoC memory controller. Then, since you have a pointer to the actual instance of the NoC module, we defined a function in our NoC module called register_mem_ctrl that indicates to the NoC that at the position x_id, y_id are the memory addresses base_address+size. Therefore, you simply call this function on the NoC module pointer by giving as parameters the attributes of the NoC memory controller.","title":"Developer Documentation"},{"location":"ExpertDocumentation/#developerexpert-documentation","text":"Please refer to the systemC repository for this part of the documentation. We will focus on an added value of VPSim, which is the dynamic instantiation of systemC modules to enable the exploration of different architectures.","title":"Developer/Expert Documentation"},{"location":"ExpertDocumentation/#why-would-you-need-a-dynamic-instanciation","text":"Actually, if you want to build a full system using systemC you will have to instantiate your modules statically. This can be a problem if you want to do automatic exploration of architectures because you will have to recompose your system and recompile your code on each minor/major modification. There is several benefits to use a dynamic instantiation: 1) Parametrization and Configurability: Dynamic instantiation allows you to parametrize your modules dynamically, making them more configurable. This is useful for example, when you want to create multiple instances of the same module with a different configuration. 2) Reusability: You can create generic modules that can be instantiated multiple times with different parameters making it easier to reuse components in different parts of your design simulated. 3) Flexible System Composition: Dynamic instantiation provides the flexibility to compose your system by adding or removing modules based on the specific requirements of the simulation.","title":"Why would you need a dynamic instanciation ?"},{"location":"ExpertDocumentation/#vpsim-approach","text":"In VPSim, we use a dynamic instantiation of the different systemC modules that will compose your system. We also automatically bind those modules between them by using a specific process that we will explain in the dynamic instantiation process part. This approach allows you to have only one executable file for all the architectures you want to explore without having to recompile the entire model each time.","title":"VPSim approach"},{"location":"ExpertDocumentation/#dynamic-instanciation-of-modules-in-vpsim","text":"For this part, we advise you to look at the UML diagram of the dynamic instanciation process. 1) SesamIp class : SesamIp is an abstract class that is here to define all the properties and functions/methods that an IP would need to be integrated in VPSim (number of in/out ports, stats of the module, required/optional attributes, port binding\u2026). It contains a static attribute called RegisteredClasses, which represents all the known classes of components (systemC modules) that VPSim can dynamically instantiate for a system build. 2) DynamicComponents : DynamicComponents is a file where you define a structure for each systemC modules you would like to instantiate dynamically in VPSim. Each structure in this file inherits from SesamIp class and contains a member, which is a pointer to a systemC module. This allow you to define specific rules and behaviours for each SystemC modules you want to include in VPSim by overloading the virtual methods declared in SesamIp class. Each structure need to be registered in the RegisteredClasses static attribute to dynamically be instantiated in VPSim. 3) PlatformBuilder : PlatformBuilder is structure used to construct a platform (collection of SesamIp instances). The goal of PlatformBuilder is to instantiate all the IPs described in the XML, bind their ports (the in/out ports of each modules are identified with a Port Alias or automatically binded), and then finalize the module (if you need to consider other systemC modules in your implementation). In short, it builds the platform, binds the ports of each modules and finalizes the modules. The order of instantiation does not count in VPSim . All the modules are instantiated and then binded automatically or with port aliases specified in the XML. When all the modules are instantiated and binded, there is the finalization phase (if a module needs to consider another module to work has expected).","title":"Dynamic instanciation of modules in VPSim"},{"location":"ExpertDocumentation/#global-approach","text":"","title":"Global approach"},{"location":"ExpertDocumentation/#sesamip-class","text":"SesamIp is an abstract class that is here to define all the properties and functions/methods that an IP would need to be integrated in VPSim (number of in/out ports, stats of the module, required/optional attributes, port binding\u2026). It contains a static attribute called RegisteredClasses, which represents all the known classes of components (systemC modules) that VPSim can dynamically instantiate for a system build.","title":"SesamIp class"},{"location":"ExpertDocumentation/#dynamiccomponents-class","text":"DynamicComponents is a file where you define a structure for each systemC modules you would like to instantiate dynamically in VPSim. Each structure in this file inherits from SesamIp class and contains a member, which is a pointer to a systemC module. This allow you to define specific rules and behaviours for each SystemC modules you want to include in VPSim by overloading the virtual methods declared in SesamIp class. Each structure need to be registered in the RegisteredClasses static attribute to dynamically be instantiated in VPSim.","title":"DynamicComponents class"},{"location":"ExpertDocumentation/#platformbuilder-class","text":"PlatformBuilder is structure used to construct a platform (collection of SesamIp instances). The goal of PlatformBuilder is to instantiate all the IPs described in the XML, bind their ports (the in/out ports of each modules are identified with a Port Alias or automatically binded), and then finalize the module (if you need to consider other systemC modules in your implementation). In short, it builds the platform, binds the ports of each modules and finalizes the modules.","title":"PlatformBuilder class"},{"location":"ExpertDocumentation/#dynamic-instanciation-process","text":"Here is a simple representation of the dynamic instanciation process in VPSim:","title":"Dynamic instanciation process"},{"location":"ExpertDocumentation/#steps-to-add-a-new-systemc-module-into-vpsim","text":"1) Include your systemC module into the dynamicComponent file so that you can reference it in a structure. 2) Define the DynamicModuleName structure related to your systemC module : - Define the required/optional attributes of the module in the constructor - Create a pointer to the actual SystemC module has a member of your structure - Overload the virtual functions of the sesamIp class. You have to overload at least the make function (Make() to instantiate the module and create a pointer to the actual systeC module) and the finalize function if you need to do something with the module in relation with other instances ONCE ALL THE OTHER MODULES ARE INSTANCIATED. 3) Register the structure you have just defined by calling registerClass (\u201cNameForXMLInterpretation\u201d) in the main. This will allow you to use it in the XML with the name \u201cNameForXMLInterpretation\u201d. Then the dynamic instantiation will be handled by platformBuilder (following the XML description of the platform).","title":"Steps to add a new systemC module into VPSim"},{"location":"ExpertDocumentation/#concrete-exemple-of-the-make-and-finalize-functions-a-noc-memory-controller","text":"Let\u2019s say you want to add a NoC memory controller into VPSim. You will have to create a new structure into DynamicComponents.hpp called \u201cDynamicNocMemoryController\u201d that inherits from SesamIp class. Constructor: For the constructor of this structure you will have to give a name as a parameter to the constructor to create a unique SesamIp object (since it inherits from sesamIp). In this constructor, you will define at least the required attributes of a NoC memory controller by calling registerRequiredAttribute from the sesamIp class. These are the required attributes for NoC memory controller: - Size represents the size that the NoC memory controller will handle - Base_address represents the base address on which the NoC memory controller starts - Noc represents the name of the NoC on which the memory controller will be assigned - x_id represents the abscissa position on the NoC where the memory controller will be assigned - y_id represents the ordinate position on the NoC where the memory controller will be assigned make function: In VPSim a memory controller isn\u2019t really a systemC module. It is a structure that defines for a NoC on which position is assigned a memory component. In this case, you only override the make function to check if the required attributes are all specified in the XML by calling the checkAttribute function from SesamIp class. finalize function: Has said, finalize is called only when all the modules that compose your platform are instantiated (so the make function has already been called on each modules). The difference between the two functions is that in finalize, you can consider other IP instances (has all the modules are instantiated). In this case, we first create a pointer to the NoC instance you want to assign the NoC memory controller. Then, since you have a pointer to the actual instance of the NoC module, we defined a function in our NoC module called register_mem_ctrl that indicates to the NoC that at the position x_id, y_id are the memory addresses base_address+size. Therefore, you simply call this function on the NoC module pointer by giving as parameters the attributes of the NoC memory controller.","title":"Concrete exemple of the make and finalize functions : a NoC memory controller"},{"location":"UserDocumentation/","text":"User Documentation Simplified representation of the interaction between the release and the binary of VPSim Release Release global approach gpp.py gpp.py is the first python layer to describe the architecture. It contains a dictionary of pairs attribute:value that will influence the second python layer, which we will talk about after. The goal of gpp.py is to describe a platform simply. This first layer makes VPSim easier to use but also facilitates design space exploration (for example, you can just change the numbers of cores very easily\u2026) armv8_platform.py armv8_platform.py is the second python layer. The goal of this file is to complete the description of gpp.py, depending on the attributes and their value. Armv8_platform describe the architecture at more concrete and low-level. It\u2019s a template of the Armv8 architecture. dt.py dt.py is a python file that dynamically generate a device tree source/blob(dts/dtb) files that will be given to the kernel. The generation is dynamic because it depends on the characteristics of the platform described in the first two python layers (gpp & armv8_platform .py). VPSim.py VPsim.py contains several classes used to generate the XML description of the platform built, considering all the python layers (gpp and armv8_platform). It also contains the location of the dtb file generated for the kernel. Then, the generated XML will be given to the VPSim binary so that it can dynamically instantiate the modules and bind their sockets. Demo Package Contents bin (/bin): Contains vpsim binary. After each simulation run, a specific folder is created here with files & results of the simulated architecture. lib (/lib): holds the modified qemu library ( ./qemu/vpsim-qemu.so ) GPP (/GPP): Contains configuration python scripts as well as linux kernel and disk image. Configure and simulate a multi-core ARMv8 system running a minimal operating system. Python (/Python): Platforms/armv8_platform.py : gives a versatile, generic ARMv8 System script that generates and configures its components based on a higher-level description. In order to abstract away for the user the whole work of composition. Libs/dt.py : generates the Device Tree to automate the process of configuring hardware components for the simulated architecture. Libs/vpsim.py : generates the final xml of the simulated architecture. SESAM userspace (/SESAM_userspace) : source code for a user space software tool used to control over the simulator for monitoring purposes and collect statistics following the execution of a specific user application and makes it possible to perform an entire exploration task. Simulation If you have entirely installed VPSim by reading the readme files in the different repositories, you can now launch simulations. Models In the Release you will find a GPP directory. This directory contains a python file descriptor of the model of General Purpose Processors (GPP) that will be used for the simulation. This file is called gpp.py . You can modify this file to change the model of the GPP. For futher information, there is a README file in the GPP directory. Launching a simulation To launch a simulation, you juste have to run the gpp.py file: python3 gpp.py Then login as root with no password. You will then be able to access the simulated system. Benchmarking To benchmark the system, you can use the sesam tool. To use it during the simulation, you can type: sesam benchmark ./[my_program] Where [my_program] is the program you want to benchmark. This will run the program and give you the results of the benchmark in a .log file located in the /bin/.EPI_GPP_VP[date]--[uniqId] directory of the release. Ending a simulation To end the simulation, juste type: sesam quit","title":"User Documentation"},{"location":"UserDocumentation/#user-documentation","text":"","title":"User Documentation"},{"location":"UserDocumentation/#simplified-representation-of-the-interaction-between-the-release-and-the-binary-of-vpsim","text":"","title":"Simplified representation of the interaction between the release and the binary of VPSim"},{"location":"UserDocumentation/#release","text":"","title":"Release"},{"location":"UserDocumentation/#release-global-approach","text":"gpp.py gpp.py is the first python layer to describe the architecture. It contains a dictionary of pairs attribute:value that will influence the second python layer, which we will talk about after. The goal of gpp.py is to describe a platform simply. This first layer makes VPSim easier to use but also facilitates design space exploration (for example, you can just change the numbers of cores very easily\u2026) armv8_platform.py armv8_platform.py is the second python layer. The goal of this file is to complete the description of gpp.py, depending on the attributes and their value. Armv8_platform describe the architecture at more concrete and low-level. It\u2019s a template of the Armv8 architecture. dt.py dt.py is a python file that dynamically generate a device tree source/blob(dts/dtb) files that will be given to the kernel. The generation is dynamic because it depends on the characteristics of the platform described in the first two python layers (gpp & armv8_platform .py). VPSim.py VPsim.py contains several classes used to generate the XML description of the platform built, considering all the python layers (gpp and armv8_platform). It also contains the location of the dtb file generated for the kernel. Then, the generated XML will be given to the VPSim binary so that it can dynamically instantiate the modules and bind their sockets.","title":"Release global approach"},{"location":"UserDocumentation/#demo-package-contents","text":"bin (/bin): Contains vpsim binary. After each simulation run, a specific folder is created here with files & results of the simulated architecture. lib (/lib): holds the modified qemu library ( ./qemu/vpsim-qemu.so ) GPP (/GPP): Contains configuration python scripts as well as linux kernel and disk image. Configure and simulate a multi-core ARMv8 system running a minimal operating system. Python (/Python): Platforms/armv8_platform.py : gives a versatile, generic ARMv8 System script that generates and configures its components based on a higher-level description. In order to abstract away for the user the whole work of composition. Libs/dt.py : generates the Device Tree to automate the process of configuring hardware components for the simulated architecture. Libs/vpsim.py : generates the final xml of the simulated architecture. SESAM userspace (/SESAM_userspace) : source code for a user space software tool used to control over the simulator for monitoring purposes and collect statistics following the execution of a specific user application and makes it possible to perform an entire exploration task.","title":"Demo Package Contents"},{"location":"UserDocumentation/#simulation","text":"If you have entirely installed VPSim by reading the readme files in the different repositories, you can now launch simulations.","title":"Simulation"},{"location":"UserDocumentation/#models","text":"In the Release you will find a GPP directory. This directory contains a python file descriptor of the model of General Purpose Processors (GPP) that will be used for the simulation. This file is called gpp.py . You can modify this file to change the model of the GPP. For futher information, there is a README file in the GPP directory.","title":"Models"},{"location":"UserDocumentation/#launching-a-simulation","text":"To launch a simulation, you juste have to run the gpp.py file: python3 gpp.py Then login as root with no password. You will then be able to access the simulated system.","title":"Launching a simulation"},{"location":"UserDocumentation/#benchmarking","text":"To benchmark the system, you can use the sesam tool. To use it during the simulation, you can type: sesam benchmark ./[my_program] Where [my_program] is the program you want to benchmark. This will run the program and give you the results of the benchmark in a .log file located in the /bin/.EPI_GPP_VP[date]--[uniqId] directory of the release.","title":"Benchmarking"},{"location":"UserDocumentation/#ending-a-simulation","text":"To end the simulation, juste type: sesam quit","title":"Ending a simulation"},{"location":"VPSim/","text":"Introduction Wath is VPSim ? VPSim VPSim is a digital architecture design environment used to speed up design space exploration (DSE) through simulation and rapid validation. Users can model a complex memory hierarchy and estimate its performance, for example, thanks to a wide variety of available processor and device models. Use Electronic systems engineers have to meet a wide array of requirements, from performance, form factor, and cost to power consumption and heat dissipation. This means making an equally wide array of complex architecture choices. VPSim leverages CEA-List\u2019s embedded systems know-how to help designers quickly explore potential architecture choices so that they can come up with a solution optimized for the target system. It ensures that all requirements\u2014power consumption, energy dissipation, latency, and form factor\u2014are satisfied. Key VPSim concepts The VPSim digital architecture design environment enables rapid design space exploration, virtual prototyping, and high-level validation\u2014during the design phase\u2014of complex digital systems. VPSim addresses all design process steps holistically with: A rich component library for efficient SystemC model construction Rapid (up to 600 MIPS) virtual prototyping simulation Co-simulation with hardware emulation capabilities It can also estimate extra-functional properties like power and temperature. Finally, VPSim supports the FMI (functional mock-up interface) standard, which means it can interface with other simulation tools so that the behavior of the physical environment can be incorporated into the validation testing of complex cyberphysical systems (CPS). VPSim also has a virtual prototyping component based on QEMU, an open-source emulator with a variety of processor and other device models, that can model complex memory hierarchies and rapidly generate prototypes. Virtual architecture prototyping based on existing components is done in Python. The Python description abstracts the underlying complexity, making it ideal for design space exploration. Another way VPSim can improve design quality is by providing an effective selection of architecture solutions. These solutions are based on operational research methods and learning methods. The latter help automate the refinement of temporal and power models from their RTL descriptions, speeding up the design space exploration process. Speed and interoperability VPSim offers a number of advantages: Fast DSE to meet designers\u2019 needs An end-to-end environment that covers everything from virtual prototyping to RTL validation SystemC/TLM 2.0 for model interoperability The tool supports the FMI standard so that the behavior of the system\u2019s physical environment can be integrated into validation tests QEMU , with its fast processor simulation capabilities Transportation, industry, security & defense VPSim is ideal for the following applications: High-performance computing (HPC): modeling of the future European high-performance processor for the European Processor Initiative (EPI) Transportation: validation of a multi-chip centralized control architecture for a car manufacturer Industry: validation of controller software execution on a virtual integrated circuit platform (digital twin) and FMI co-simulation for modeling of the physical environment\u2019s interactions Security & defense: current leakage assessment for a security analysis General overview of VPSim","title":"Introduction"},{"location":"VPSim/#introduction","text":"","title":"Introduction"},{"location":"VPSim/#wath-is-vpsim","text":"VPSim VPSim is a digital architecture design environment used to speed up design space exploration (DSE) through simulation and rapid validation. Users can model a complex memory hierarchy and estimate its performance, for example, thanks to a wide variety of available processor and device models.","title":"Wath is VPSim ?"},{"location":"VPSim/#use","text":"Electronic systems engineers have to meet a wide array of requirements, from performance, form factor, and cost to power consumption and heat dissipation. This means making an equally wide array of complex architecture choices. VPSim leverages CEA-List\u2019s embedded systems know-how to help designers quickly explore potential architecture choices so that they can come up with a solution optimized for the target system. It ensures that all requirements\u2014power consumption, energy dissipation, latency, and form factor\u2014are satisfied.","title":"Use"},{"location":"VPSim/#key-vpsim-concepts","text":"The VPSim digital architecture design environment enables rapid design space exploration, virtual prototyping, and high-level validation\u2014during the design phase\u2014of complex digital systems. VPSim addresses all design process steps holistically with: A rich component library for efficient SystemC model construction Rapid (up to 600 MIPS) virtual prototyping simulation Co-simulation with hardware emulation capabilities It can also estimate extra-functional properties like power and temperature. Finally, VPSim supports the FMI (functional mock-up interface) standard, which means it can interface with other simulation tools so that the behavior of the physical environment can be incorporated into the validation testing of complex cyberphysical systems (CPS). VPSim also has a virtual prototyping component based on QEMU, an open-source emulator with a variety of processor and other device models, that can model complex memory hierarchies and rapidly generate prototypes. Virtual architecture prototyping based on existing components is done in Python. The Python description abstracts the underlying complexity, making it ideal for design space exploration. Another way VPSim can improve design quality is by providing an effective selection of architecture solutions. These solutions are based on operational research methods and learning methods. The latter help automate the refinement of temporal and power models from their RTL descriptions, speeding up the design space exploration process.","title":"Key VPSim concepts"},{"location":"VPSim/#speed-and-interoperability","text":"VPSim offers a number of advantages: Fast DSE to meet designers\u2019 needs An end-to-end environment that covers everything from virtual prototyping to RTL validation SystemC/TLM 2.0 for model interoperability The tool supports the FMI standard so that the behavior of the system\u2019s physical environment can be integrated into validation tests QEMU , with its fast processor simulation capabilities","title":"Speed and interoperability"},{"location":"VPSim/#transportation-industry-security-defense","text":"VPSim is ideal for the following applications: High-performance computing (HPC): modeling of the future European high-performance processor for the European Processor Initiative (EPI) Transportation: validation of a multi-chip centralized control architecture for a car manufacturer Industry: validation of controller software execution on a virtual integrated circuit platform (digital twin) and FMI co-simulation for modeling of the physical environment\u2019s interactions Security & defense: current leakage assessment for a security analysis","title":"Transportation, industry, security &amp; defense"},{"location":"VPSim/#general-overview-of-vpsim","text":"","title":"General overview of VPSim"},{"location":"content/","text":"VPSim-Main-Repositorie You can find the main repository of VPSim here . In this repository, you will find three submodules: 1. vpsim-qemu : The official QEMU fork for VPSim. Support of VPSim model provider Interface. 2. vpsim-systemC : Wich contains the files used to generate the VPSim binary. And wich we will talk about in the Developer Documentation section. 3. vpsim-release : Wich contains the Python release of VPSim. And wich we will describe in the User Documentation section. Demo-package-content In each of these submodules repositories, you will find a README file that contains more information.","title":"Main repository"},{"location":"content/#vpsim-main-repositorie","text":"You can find the main repository of VPSim here . In this repository, you will find three submodules:","title":"VPSim-Main-Repositorie"},{"location":"content/#1-vpsim-qemu","text":"The official QEMU fork for VPSim. Support of VPSim model provider Interface.","title":"1. vpsim-qemu:"},{"location":"content/#2-vpsim-systemc","text":"Wich contains the files used to generate the VPSim binary. And wich we will talk about in the Developer Documentation section.","title":"2. vpsim-systemC:"},{"location":"content/#3-vpsim-release","text":"Wich contains the Python release of VPSim. And wich we will describe in the User Documentation section.","title":"3. vpsim-release:"},{"location":"content/#demo-package-content","text":"In each of these submodules repositories, you will find a README file that contains more information.","title":"Demo-package-content"},{"location":"contributing/","text":"Contributing Contributing to VPSim We welcome contributions to VPSim! We're thrilled that you'd like to contribute to this project. Your help is essential to keep it great. How to contribute To contribute to VPSim or VPSim documentation, follow the following steps: 1. Fork and clone the concerned repository. 2. Do the changes on your fork. 3. Submit a pull request to the main repository so that your changes can be reviewed and merged. For more information, please refer to the GitHub documentation . Release process At the moment, the release process is manual. The release is done by the maintainers of the project. We try to make frequent releases to keep the project up to date and to provide the best experience for you. Usually, we release a new version when we have a new feature or a bug fix.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#contributing-to-vpsim","text":"We welcome contributions to VPSim! We're thrilled that you'd like to contribute to this project. Your help is essential to keep it great.","title":"Contributing to VPSim"},{"location":"contributing/#how-to-contribute","text":"To contribute to VPSim or VPSim documentation, follow the following steps: 1. Fork and clone the concerned repository. 2. Do the changes on your fork. 3. Submit a pull request to the main repository so that your changes can be reviewed and merged. For more information, please refer to the GitHub documentation .","title":"How to contribute"},{"location":"contributing/#release-process","text":"At the moment, the release process is manual. The release is done by the maintainers of the project. We try to make frequent releases to keep the project up to date and to provide the best experience for you. Usually, we release a new version when we have a new feature or a bug fix.","title":"Release process"},{"location":"uml/","text":"UML In this section, we will provide some UML diagrams to help you understand the architecture of VPSim. Class Diagrams Release link to download the visual paradigm project In this file, you will also find the sequence diagram of a simulation in the VPSim release. Dynamic Instanciation of SystemC modules (in VPSim Binary) link to download the visual paradigm project","title":"UML"},{"location":"uml/#uml","text":"In this section, we will provide some UML diagrams to help you understand the architecture of VPSim.","title":"UML"},{"location":"uml/#class-diagrams","text":"","title":"Class Diagrams"},{"location":"uml/#release","text":"link to download the visual paradigm project In this file, you will also find the sequence diagram of a simulation in the VPSim release.","title":"Release"},{"location":"uml/#dynamic-instanciation-of-systemc-modules-in-vpsim-binary","text":"link to download the visual paradigm project","title":"Dynamic Instanciation of SystemC modules (in VPSim Binary)"}]}